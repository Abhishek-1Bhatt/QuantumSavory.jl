using ResumableFunctions
import ConcurrentSim # Should be using
using ConcurrentSim: Environment, request, release, now, active_process, timeout, Store, @process, Process, put, get
using Printf

export @simlog, isfree, nongreedymultilock, spinlock, DelayChannel

macro simlog(env, msg) # this should be part of @process or @resumable and just convert @info and company
    return :(@info(@sprintf("t=%.4f @ %05d : %s", now($(esc(env))), active_process($(esc(env))).bev.id, $(esc(msg)))))
end

isfree(resource) = resource.level == 0

@resumable function nongreedymultilock(env::Environment, resources)
    while true
        if all(isfree(r)::Bool for r in resources) # type assert to help with inference
            @yield mapreduce(request, &, resources)
            break
        else
            for r in resources
                if !isfree(r)
                    @yield request(r)
                    release(r)
                    break
                end
            end
        end
    end
end

@resumable function spinlock(env::Environment, resources, period; randomize=true)
    while true
        if all(isfree, resources)
            @yield mapreduce(request, &, resources)
            break
        else
            if randomize
                @yield timeout(env, rand()*period)
            else
                @yield timeout(env, period)
            end
        end
    end
end

mutable struct DelayChannel{T}
    delay::Float64
    store::Store{T}
end
function DelayChannel(env::Environment, delay::Float64)
    return DelayChannel(delay, Store{Any}(env))
end
function DelayChannel{T}(env::Environment, delay::Float64) where T
    return DelayChannel(delay, Store{T}(env))
end

@resumable function latency(env::Environment, channel::DelayChannel, value)
    @yield timeout(channel.store.env, channel.delay)
    put(channel.store, value)
end

function ConcurrentSim.put(channel::DelayChannel, value) # TODO rename to the ones from Base
    @process latency(channel.store.env, channel, value) # results in the scheduling of all events generated by latency
end

function ConcurrentSim.get(channel::DelayChannel) # TODO rename to the ones from Base
    get(channel.store) # returns an element stored in the cable store
end
